`timescale 1ns/1ps

module memory (input [31:0] addr, input [31:0] data_in, input wena, input clk,
    output reg [31:0] data_out);

    // 32-bit address
    // Due to the limit of Vivado synthesis, only offer a 1KB memory (8-bit address) by word
    reg [31:0] mem [255:0];
    wire [7:0] addr8 = addr[9:2];

    // Data memory
    // Stack Pointer ($sp) initializes at 10'd1020 (0x3FC)

    // Instruction memory
    // Instruction address begins at 10'd0 (0x000)
    initial begin
        mem[0]  <= 32'b001101_00000_11101_0000001111111100; //	0	initialization:	ori $sp, $zero, 0x3FC		ori $29, $0, 0x3FC
        mem[1]  <= 32'b001101_00000_10001_0000000000000100; //	4		ori $s1, $zero, 0x4
        mem[2]  <= 32'b000000_00000_10001_10010_00001_000010; //	8		srl $s2, $s1, 0x1
        mem[3]  <= 32'b000000_10001_10010_10011_00000_100100; //	C		and $s3, $s1, $s2
        mem[4]  <= 32'b000000_10001_10010_10100_00000_100000; //	10		add $s4, $s1, $s2
        mem[5]  <= 32'b001110_00000_10101_0000000000000001; //	14		xori $s5, $zero, 0x1		xori $21, $0, 0x1
        mem[6]  <= 32'b001101_00000_10000_0000000000000101; //	main:	18	ori $s0, $zero, 0x5	#int n = 5;	ori $16, $0, 0x5
        mem[7]  <= 32'b000000_00000_10000_01101_00010_000000; //		1C	sll $t5, $s0, 0x2	#t5 = 4*n	sll $13, $16, 0x2
        mem[8]  <= 32'b000000_11101_01101_11101_00000_100010; //		20	sub $sp, $sp, $t5	#int arr[n];	sub $29, $29, $13
        mem[9]  <= 32'b001000_11101_11101_0000000000000100; //		24	addi $sp, $sp, 0x4	#locate arr[0]	addi $29, $29, 0x4
        mem[10] <= 32'b101011_11101_10001_0000000000000000; //		28	sw  $s1, 0($sp)	#arr[0] = s1;	sw $17, 0, $29
        mem[11] <= 32'b001000_11101_11101_0000000000000100; //		2C	addi $sp, $sp, 0x4	#locate arr[1]	addi $29, $29, 0x4
        mem[12] <= 32'b101011_11101_10010_0000000000000000; //		30	sw  $s2, 0($sp)	#arr[1] = s2;	sw $18, 0, $29
        mem[13] <= 32'b001000_11101_11101_0000000000000100; //		34	addi $sp, $sp, 0x4	#locate arr[2]	addi $29, $29, 0x4
        mem[14] <= 32'b101011_11101_10011_0000000000000000; //		38	sw  $s3, 0($sp)	#arr[2] = s3;	sw $19, 0, $29
        mem[15] <= 32'b001000_11101_11101_0000000000000100; //		3C	addi $sp, $sp, 0x4	#locate arr[3]	addi $29, $29, 0x4
        mem[16] <= 32'b101011_11101_10100_0000000000000000; //		40	sw  $s4, 0($sp)	#arr[3] = s4;	sw $20, 0, $29
        mem[17] <= 32'b001000_11101_11101_0000000000000100; //		44	addi $sp, $sp, 0x4	#locate arr[4]	addi $29, $29, 0x4
        mem[18] <= 32'b101011_11101_10101_0000000000000000; //		48	sw  $s5, 0($sp)	#arr[4] = s5;	sw $21, 0, $29
        mem[19] <= 32'b000000_10000_00000_00100_00000_100101; //		4C	or  $a0, $s0, $zero	#a0 = n	or $4, $16, $0
        mem[20] <= 32'b000011_00000000000000000000010110; //		50	jal BubbleSort	#BubbleSort(n,arr);	jal BubbleSort
        mem[21] <= 32'b000010_00000000000000000000111110; //		54	j   endprogram	#return 0;	j endprogram
        mem[22] <= 32'b000000_00100_00000_01111_00000_100110; //	BubbleSort:	58	xor $t7, $a0, $zero	#t7 = n; XOR is the same as OR	xor $15, $4, $0
        mem[23] <= 32'b000000_00000_00100_01101_00010_000000; //		5C	sll $t5, $a0, 0x2	#t5 = 4*n	sll $13, $4, 0x2
        mem[24] <= 32'b001101_00000_01000_0000000000000000; //		60	ori $t0, $zero, 0x0	#int i = 0;	ori $8, $0, 0x0
        mem[25] <= 32'b001101_00000_01110_0000000000000001; //		64	ori $t6, $zero, 0x1	#t6 = 1	ori $14, $0, 0x1
        mem[26] <= 32'b000000_01111_01110_01001_00000_100010; //		68	sub $t1, $t7, $t6	#t1 = n-1	sub $9, $15, $14
        mem[27] <= 32'b000000_11101_01101_11101_00000_100010; //		6C	sub $sp, $sp, $t5	#initialize stack, locate arr[-1]	sub $29, $29, $13
        mem[28] <= 32'b001000_11101_11101_0000000000000100; //		70	addi $sp, $sp, 0x4	#locate arr[0]	addi $29, $29, 0x4
        mem[29] <= 32'b000000_01000_01001_01110_00000_100010; //	outerloop:	74	sub $t6, $t0, $t1		sub $14, $8, $9
        mem[30] <= 32'b000100_01110_00000_0000000000010010; //		78	beq $t6, $zero, endouter	#i < n-1;	beq $14, $0, endouter
        mem[31] <= 32'b001101_00000_01010_0000000000000000; //		7C	ori $t2, $zero, 0x0	#int k = 0;	ori $10, $0, 0x0
        mem[32] <= 32'b000000_01001_01000_01011_00000_100010; //		80	sub $t3, $t1, $t0	#t3 = n-1-i	sub $11, $9, $8
        mem[33] <= 32'b000000_01010_01011_01110_00000_100010; //	innerloop:	84	sub $t6, $t2, $t3		sub $14, $10, $11
        mem[34] <= 32'b000100_01110_00000_0000000000001010; //		88	beq $t6, $zero, endinner	#k < n-i-1;	beq $14, $0, endinner
        mem[35] <= 32'b100011_11101_11000_0000000000000000; //		8C	lw  $t8, 0($sp)	#t8 = arr[k]	lw $24, 0, $29
        mem[36] <= 32'b100011_11101_11001_0000000000000100; //		90	lw  $t9, 4($sp)	#t9 = arr[k+1]	lw $25, 4, $29
        mem[37] <= 32'b000000_11000_11001_01110_00000_100010; //		94	sub $t6, $t8, $t9		sub $14, $24, $25
        mem[38] <= 32'b000000_00000_01110_01110_11111_000011; //		98	sra $t6, $t6, 0x1F	#fetch the sign bit	sra $14, $14, 0x1F
        mem[39] <= 32'b000100_01110_00000_0000000000000010; //		9C	beq $t6, $zero, nochange	#if(arr[k] > arr[k+1])	beq $14, $0, nochange
        mem[40] <= 32'b101011_11101_11000_0000000000000100; //		A0	sw  $t8, 4($sp)		sw $24, 4, $29
        mem[41] <= 32'b101011_11101_11001_0000000000000000; //		A4	sw  $t9, 0($sp)	#swap(arr[k], arr[k+1]);	sw $25, 0, $29
        mem[42] <= 32'b001000_01010_01010_0000000000000001; //	nochange:	A8	addi $t2, $t2, 0x1	#k++;	addi $10, $10, 0x1
        mem[43] <= 32'b001000_11101_11101_0000000000000100; //		AC	addi $sp, $sp, 0x4	#locate arr[k]	addi $29, $29, 0x4
        mem[44] <= 32'b000010_00000000000000000000100001; //		B0	j innerloop		j innerloop
        mem[45] <= 32'b000000_00000_01011_01100_00010_000000; //	endinner:	B4	sll $t4, $t3, 0x2		sll $12, $11, 0x2
        mem[46] <= 32'b000000_11101_01100_11101_00000_100010; //		B8	sub $sp, $sp, $t4	#locate arr[0]	sub $29, $29, $12
        mem[47] <= 32'b001000_01000_01000_0000000000000001; //		BC	addi $t0, $t0, 0x1	#i++;	addi $8, $8, 0x1
        mem[48] <= 32'b000010_00000000000000000000011101; //		C0	j outerloop		j outerloop
        mem[49] <= 32'b001101_00000_01110_0000000000000100; //	endouter:	C4	ori $t6, $zero, 0x4	#t6 = 4	ori $14, $0, 0x4
        mem[50] <= 32'b000000_11101_01110_11101_00000_100010; //		C8	sub $sp, $sp, $t6	#locate arr[-1]	sub $29, $29, $14
        mem[51] <= 32'b001000_11101_11101_0000000000000100; //		CC	addi $sp, $sp, 0x4	#locate arr[0]	addi $29, $29, 0x4
        mem[52] <= 32'b100011_11101_10001_0000000000000000; //		D0	lw  $s1, 0($sp)	#s1 = arr[0];	lw $17, 0, $29
        mem[53] <= 32'b001000_11101_11101_0000000000000100; //		D4	addi $sp, $sp, 0x4	#locate arr[1]	addi $29, $29, 0x4
        mem[54] <= 32'b100011_11101_10010_0000000000000000; //		D8	lw  $s2, 0($sp)	#s2 = arr[1];	lw $18, 0, $29
        mem[55] <= 32'b001000_11101_11101_0000000000000100; //		DC	addi $sp, $sp, 0x4	#locate arr[2]	addi $29, $29, 0x4
        mem[56] <= 32'b100011_11101_10011_0000000000000000; //		E0	lw  $s3, 0($sp)	#s3 = arr[2];	lw $19, 0, $29
        mem[57] <= 32'b001000_11101_11101_0000000000000100; //		E4	addi $sp, $sp, 0x4	#locate arr[3]	addi $29, $29, 0x4
        mem[58] <= 32'b100011_11101_10100_0000000000000000; //		E8	lw  $s4, 0($sp)	#s4 = arr[3];	lw $20, 0, $29
        mem[59] <= 32'b001000_11101_11101_0000000000000100; //		EC	addi $sp, $sp, 0x4	#locate arr[4]	addi $29, $29, 0x4
        mem[60] <= 32'b100011_11101_10101_0000000000000000; //		F0	lw  $s5, 0($sp)	#s5 = arr[4];	lw $21, 0, $29
        mem[61] <= 32'b000000_11111_00000_00000_00000_001000; //	endprint:	F4	jr $ra		jr $31
        mem[62] <= 32'b001111_00000_10110_1111111111111111; //	F8	endprogram:	lui $s6, 0xFFFF	#End of bubble sort; lui test	lui $22, 0xFFFF
        mem[63] <= 32'b001100_10110_10110_0000000011001100; //	FC		andi $s6, $s6, 0xCC	#andi test	andi $22, $22, 0xCC
        mem[64] <= 32'b000101_10110_11101_0000000000001100; //	100		bne $s6, $sp, endtest	#bne test	bne $22, $29, 0xC

    end

    // Data Write
    always @(posedge clk) begin
        if (wena) begin
            mem[addr8] <= data_in;
        end
    end

    always @(*) begin
        // Data Read
        data_out <= mem[addr8];
    end

endmodule